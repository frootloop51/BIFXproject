

######################################################

# Tool 1A: Identify that a genomic region in an intron or between genes is expressed based on RNAseq data
# Author: Ian Lacy
# Date: March 27, 2024
#####################################################

# The purpose of this script is to analyze all samples in each study of interest and measure coverage across a region of the genome between specific genomic coordinates.
#There are three steps to complete the analysis.  
#The script begins with generating a BED annotation file that specifies the putative exons that the user wishes to check for differential expression. The second step
#includes calculating the coverage of the desired regions and combining  all of the coverage matrices into one overall coverage matrix.  
#The third step includes Exploratory/Visual Analysis.

#Note: this script is very much incomplete and I need significant feedback on where to go from here.

#####################################################


# Step One: Creating a BED file for processing BigWig Files

# load the necessary packages needed to complete the differential expression analysis
library(GenomicRanges) #a megadepth tool will eventually generate a GRanges object
library(recount3) #loads the study information
library(megadepth) #provides new tools for analysis, including the get_coverage function which seems to streamline a lot of work.
library(dplyr)


#Creating a BED file from the CSV generated by Professor Darby's GRange generating script
csv_data <- read.csv("C:/Users/ianla.000/Documents/bifxproject/NovelCommonMajorExons.csv", header=TRUE) #This file was generated from Dr. Darby's script which gives the genomic coordinates.

csv_data <- setNames(csv_data, c("chrom", "chromStart", "chromEnd", "strand"))
csv_data

# Write to BED file
write.table(csv_data, "annotation_file.bed", sep="\t", col.names = FALSE, row.names=FALSE, quote=FALSE)

#####################################################

# Step Two: Calculating coverage of the desired regions


##calculate coverage using get_coverage from megadepth
##This is only an example piece of code to prove that it works. I am working on creating a loop that will look
## at many BigWig Files and create GRanges objects for each of them. 


folder_path <- "C:/Users/ianla.000/Documents/bifxproject/bigwigs" #defines directory where you want list.files to work
file_pattern <- "*.bw"  # defines regular expression to be used in list.files to identify files that end in .bw

file_paths <- list.files(folder_path, pattern = file_pattern, full.names = TRUE)


annotation_file <- "C:/Users/ianla.000/Documents/bifxproject/annotation_file.bed"

BW_outputs <- list()

for (file_path in file_paths) {

  # Extract a unique identifier from the file path
  unique_name <- basename(file_path) #uses file path as the unique name for the GRanges object
  
  # Call the get_coverage function
  coverage_output <- get_coverage(
    file_path,
    op = "mean", # mean base-pair coverage for each input region
    annotation = annotation_file
  )
  
  # Store the output in a list with the file name as the key
  BW_outputs[[unique_name]] <- coverage_output
}

BW_outputs

target <- 5

for (i in seq_along(BW_outputs)) {
  # evaluates the coverage score and returns a logical value (True of false).
  GreaterThanFive <- mcols(BW_outputs[[i]])$score >= target
  
  # Add the logical vector as a new metadata column
  mcols(BW_outputs[[i]])$threshold <- GreaterThanFive
}


outpts_df <- lapply(BW_outputs, as.data.frame) #converts each item in the list to a dataframe
combo_outpts <- bind_rows(outpts_df) #binds all rows from each dataframe into one dataframe
combo_outpts
combo_outpts$seqnames <- as.character(combo_outpts$seqnames) #converst the seqnames columns to characters for further manipulation.

#this code block filters out all of the values when threshold is TRUE
combo_outpts <- combo_outpts %>%
  filter(threshold != FALSE)
combo_outpts


combo_outpts1 <- unique(combo_outpts$seqnames) #identifies the unique chromosomes in this column
combo_outpts1

chr_list <- as.list(combo_outpts1) #ensures that unique chromosome values are in list

chrom_list <- list() #initializes an empty list to copy a list of chromosomes grouped by chromosome

#this loop uses the chr_list to evaluate the condition in the loop
for (chrom in chr_list){
    chrom_list[[chrom]]  <- combo_outpts[combo_outpts$seqnames == chrom,] #if the value in seqnames equals chrom it copies into the new list: chrom_list
} 
chrom_list   

#This segment removes the threshold column because it will not be needed in the next step of the pipeline/in the CSV
for (i in seq_along(chrom_list)) {
  chrom_list[[i]]$threshold <- NULL
}
chrom_list

df_chrom_names <- names(chrom_list) #names took the name of each element in the list which is the chromosome name

#uses names from list to evaluate a function.
for (name in df_chrom_names){
  file <- paste0(name, ".csv")
  write.csv(chrom_list[[name]], file, row.names = FALSE)
}





#Step 3: Visualization and Analysis
# TBD